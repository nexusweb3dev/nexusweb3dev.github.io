# The $26M Integer Overflow That Sat Dormant for 5 Years

**On January 8, 2026, a single transaction drained $26.2M from TrueBit — a protocol that hadn't been touched since 2021.**

The exploit wasn't sophisticated. No zero-day. No novel attack vector. Just basic integer overflow arithmetic from the Solidity dark ages.

Here's how legacy code became a $26M payday — and why DeFi's archives are the new frontier for attackers.

---

## The Bug: Addition Without SafeMath

TrueBit's bonding curve contract was deployed in **Solidity v0.5.3** — before Solidity 0.8.0 introduced automatic overflow checks.

The `getPurchasePrice()` function calculated the ETH cost to mint TRU tokens:

```solidity
function getPurchasePrice(uint256 amount) public view returns (uint256) {
    uint256 cost = basePrice + (supply * multiplier); // ← BOOM
    return cost;
}
```

**The problem:** While multiplication and division used SafeMath, this ONE addition operation didn't.

**The result:**
- Normal input (1,000 tokens): Returns reasonable ETH price
- Astronomical input (240M+ tokens): Addition overflows, wraps to ~0

**The exploit:** Mint billions of tokens for near-zero ETH, burn them for 12.5% buyback rate, profit.

---

## The Attack: One Transaction, 8,535 ETH

The attacker's execution was clinical:

1. **Preparation (Nov-Dec 2025):** Funded wallet via Rhino.fi bridge (privacy-focused)
2. **Deployment (Jan 8, 2026):** Attack contract deployed in private mempool (block position 3)
3. **Execution (same block, position 4):** Five-iteration loop in one atomic tx:
   - Query `getPurchasePrice(240442509 TRU)` → returns ~0 (overflow)
   - Mint 240M+ tokens for negligible ETH
   - Burn tokens → receive real ETH at 12.5% buyback
   - Repeat with larger amounts (no supply cap)
4. **Extract:** 8,535 ETH drained
5. **Launder:** All funds → Tornado Cash via intermediary wallets

**Attack tx hash:** `0xcd4755645595094a8ab984d0db7e3b4aabde72a5c87c4f176a030629c47fb014`

**Function name in the transaction:** Literally labeled "Attack"

---

## The Warning That Was Ignored

**Banteg (Yearn core dev) flagged this in 2021:**
> "This is entering the rug zone." — [Twitter, April 2021](https://x.com/banteg/status/1389032239162347521)

The warning sat for **five years**. The contract was unverified (bytecode only on Etherscan). No published audits. No fixes.

The attacker wasn't lucky. They were systematic.

---

## The Pattern: Serial Hunter

This wasn't opportunistic. **12 days before TrueBit, the same attacker hit Sparkle protocol for 5 ETH** — a test run.

Wallet: `0x6c8ec8f14be7c01672d31cfa5f2cefeab2562b50`

**The hunting pattern:**
1. Scan for old protocols (deployed pre-2021)
2. Filter for Solidity <0.8.0 (no auto overflow checks)
3. Find unverified bytecode contracts
4. Test on small protocols (Sparkle = $5K)
5. Execute on big protocols (TrueBit = $26M)

**2025-2026 trend:** Balancer (5yr old), Yearn yETH (old pool), Abracadabra (deprecated), Aevo (old vaults), Rari (ceased ops), TrueBit (5yr old).

**DeFi's archives ARE the new frontier.**

---

## How This Should Have Been Caught

### Detection Before Deployment

**1. Compiler version check:**
```bash
grep "pragma solidity" contracts/*.sol
# If ^0.[0-7].* → HIGH RISK (no auto overflow checks)
```

**2. SafeMath coverage audit:**
```bash
grep -rn "using SafeMath" contracts/
grep -rn "\.add\(\|\.sub\(\|\.mul\(\|\.div\(" contracts/
# Check: ALL arithmetic uses SafeMath, or use Solidity >=0.8.0
```

**3. Invariant test (would catch immediately):**
```solidity
function invariant_price_monotonic() public {
    uint256 cost1 = purchase.getPurchasePrice(1000);
    uint256 cost3 = purchase.getPurchasePrice(1000000000);
    
    // Cost must increase with amount
    assertGe(cost3, cost1, "Price decreased — overflow detected");
}
```

**4. Red flags:**
- Unverified bytecode on Etherscan
- No published audits for financial contracts
- Bonding curve math without bounds checking
- Unlimited mint with no per-tx caps

---

## The Fix (Simple)

### Modern Solidity (0.8.0+):
```solidity
pragma solidity ^0.8.0;

function getPurchasePrice(uint256 amount) public view returns (uint256) {
    uint256 cost = basePrice + (supply * multiplier); // ← Auto-reverts on overflow
    return cost;
}
```

### Legacy Solidity (<0.8.0):
```solidity
pragma solidity ^0.5.0;
import "@openzeppelin/contracts/math/SafeMath.sol";

contract BondingCurve {
    using SafeMath for uint256;
    
    function getPurchasePrice(uint256 amount) public view returns (uint256) {
        uint256 supplyCost = supply.mul(multiplier);
        uint256 cost = basePrice.add(supplyCost); // ← SafeMath addition
        return cost;
    }
}
```

**Additional protections:**
- Supply caps (max total supply)
- Per-transaction mint limits
- Price bounds (minimum floor)
- Verified source code
- Published audits

---

## Lessons for Protocol Developers

1. **Old code = prime targets.** If you deployed before 2021 and haven't upgraded compiler versions, you're on the hunter's list.

2. **Unverified bytecode = no audit possible.** If the public can't read your code, neither can security researchers. Verify on Etherscan.

3. **Warnings without action = zero value.** Banteg's 2021 warning didn't fix anything. Ship the fix or the warning is worthless.

4. **Legacy maintenance matters.** Teams ship new products, abandon old contracts. Those contracts still hold value. Attackers know this.

5. **Test for edge cases.** Invariant tests catch overflow bugs trivially. Add monotonicity checks to all pricing functions.

---

## Lessons for Attackers (Educational)

The TrueBit attacker demonstrated a calculated approach:

- **Reconnaissance:** Target old protocols with unverified code
- **Testing:** Small exploit first (Sparkle), validate methodology
- **Execution:** Atomic transaction, private mempool, immediate laundering
- **Profit:** $26M in one tx

**If you're a white-hat:** This is the playbook. Find these bugs FIRST, report them, earn bounties.

**If you're a protocol:** Assume someone is running this playbook RIGHT NOW on your old contracts.

---

## What Happens Next?

**Copycat attacks:** A second attacker extracted ~$253K after seeing the exploit tx.

**Funds status:** All ETH → Tornado Cash. Not recoverable.

**Attacker status:** Still active. Wallet shows continued on-chain activity.

**Other protocols at risk:** Any pre-2021 contract with unverified code, unchecked arithmetic, and >$100K TVL.

---

## Conclusion

TrueBit lost $26M to a bug pattern that's been known and preventable since 2018.

The attacker didn't innovate. They just did their homework.

**If your protocol deployed before Solidity 0.8.0 and you haven't audited arithmetic operations:** You're not safe. You're unaudited.

**Legacy code doesn't age like wine. It ages like milk.**

Fix it before someone else finds it.

---

**References:**
- Attack tx: [Etherscan](https://etherscan.io/tx/0xcd4755645595094a8ab984d0db7e3b4aabde72a5c87c4f176a030629c47fb014)
- Banteg's 2021 warning: [Twitter](https://x.com/banteg/status/1389032239162347521)
- TrueBit contract: `0x764C64b2A09b09Acb100B80d8c505Aa6a0302EF2`

---

*This content is educational. All exploit details are publicly documented on-chain and via security research platforms.*
