# The $4.1M Oracle Manipulation That 6 Audits Missed

**On January 20, 2026, Makina Finance lost $4.13M to an oracle manipulation attack that was explicitly excluded from audit scope.**

The protocol had **six audits** from top-tier firms. ChainSecurity. OtterSec. SigmaPrime. Cantina. Enigma Dark.

And yet, the vulnerability that killed it was marked "out of scope."

Here's how audit exclusions become attack vectors — and why MEV bots are faster than exploit authors.

---

## The Bug: Permissionless Spot Price Oracle

Makina's vulnerability wasn't subtle. It was TEXTBOOK oracle manipulation:

**Vulnerable pattern:**
```solidity
// ANYONE can call this
function updateTotalAum() public {
    // Pulls SPOT PRICE from Curve pool
    uint256 curveValue = curvePool.calc_withdraw_one_coin(balance, coinIndex);
    
    // Locks manipulated value into state
    lastTotalAum = curveValue;
    updateSharePrice(); // ← Uses manipulated AUM for LP valuation
}
```

**Three fatal flaws:**
1. **Permissionless:** Anyone can call `updateTotalAum()` anytime (including mid-exploit)
2. **Spot price:** Queries current Curve pool state, not TWAP (time-weighted average)
3. **Atomic execution:** No delay between price update and withdrawal

**Result:** Flash loan → manipulate pool → update oracle → extract value → profit. All in one transaction.

---

## The Attack: Flash Loan + Curve Pool Manipulation

**Execution (atomic in one tx):**

1. **Flash loan 280M USDC**
   - Morpho: 160.6M USDC
   - Aave V2: 119.4M USDC

2. **Manipulate Curve pools**
   - Dump 170M USDC into DUSD/USDC + 3pool + MIM-3CRV
   - Pool balances skew heavily toward USDC
   - DUSD appears artificially more valuable

3. **Lock the lie**
   - Call `accountForPosition()` → triggers `updateTotalAum()`
   - Function queries `calc_withdraw_one_coin()` on manipulated pools
   - Inflated values returned
   - Share price recalculated at inflated rate

4. **Extract value**
   - Trade 110M USDC into DUSD/USDC pool
   - Pool pays out at manipulated share price
   - Withdraw LP tokens at inflated valuation
   - Pool bleeds 5.1M USDC

5. **Profit**
   - Repay flash loans
   - Keep ~$4.13M
   - Convert to WETH, exit

**Attack tx:** `0x569733b8016ef9418f0b6bde8c14224d9e759e79301499908ecbcd956a0651f5`

---

## The Twist: MEV Front-Running

**Original attacker:** `0x2F934B0Fd5c4f99BAb37d47604a3a1AEADEF1CCc`
**MEV bot:** `0x935bfb495E33f74d2E9735DF1DA66acE442ede48`

**What happened:**
1. Original attacker deploys exploit contract
2. MEV searcher **decompiles the bytecode** in the mempool
3. MEV bot replicates the attack in the NEXT BLOCK
4. MEV bot captures **100% of the funds** (1,299 ETH)
5. Original attacker gets **0 ETH**

**Lesson:** Even exploits get front-run. Unverified attack contracts = public blueprints for MEV.

**Funds distribution:**
- `0xbed26250Db2097318386F540fD546acEDf7bdE25`: 1,062 ETH (~$3.3M)
- `0x573Db3Aed219EfD4D2cDABC0D00366E7B80F910E`: 276 ETH (~$880K) [Rocket Pool validator]

---

## The Audit Warning That Was Ignored

**Cantina CTF (Sept-Oct 2025)** explicitly listed this as **OUT OF SCOPE:**

> "Losses caused by oracle price/liquidity pool manipulation, where an unchecked synchronous deposit is used."

**Translation:** "We didn't check if flash loans can manipulate your oracle. Assume it's fine."

**Three months later:** Attacker exploits the EXACT pattern marked out of scope.

**Key insight:** "Out of scope" ≠ "safe." It means "unaudited risk you accepted."

---

## Why This Happened: Post-Audit Integrations

Makina had **six audits** from top firms:
- ChainSecurity
- OtterSec
- SigmaPrime
- Cantina
- Enigma Dark
- Halborn

**But:** The Curve pool integration was deployed **AFTER** audits completed.

**Pattern:**
1. Protocol gets audited (codebase A)
2. Protocol integrates with Curve (codebase B)
3. New integration = new attack surface
4. No re-audit performed
5. Attacker exploits post-audit changes

**Lesson:** New integrations = new audits required. Period.

---

## How This Should Have Been Caught

### Detection Before Deployment

**1. Grep for permissionless oracle updates:**
```bash
grep -rn "function.*update.*price\|function.*update.*aum" contracts/
grep -A5 "external\|public" contracts/*.sol | grep -i "price\|oracle"
```

**2. Check for spot price queries without TWAP:**
```bash
grep -rn "calc_withdraw_one_coin\|get_virtual_price" contracts/
# If found: verify TWAP or time delay exists
```

**3. Invariant test (catches same-block manipulation):**
```solidity
function invariant_price_cannot_spike() public {
    uint256 priceBefore = vault.getSharePrice();
    
    // Simulate large pool manipulation
    // ... (flash loan simulation) ...
    
    vault.updateTotalAum();
    uint256 priceAfter = vault.getSharePrice();
    
    // Price should not move >1% in one tx
    uint256 delta = priceAfter > priceBefore ? 
        priceAfter - priceBefore : priceBefore - priceAfter;
    
    assertLt(delta * 100 / priceBefore, 1, "Price spiked >1% in one tx");
}
```

**4. Manual checklist:**
- [ ] Is share price oracle permissionless?
- [ ] Does it use spot prices from AMM pools?
- [ ] Can price be updated same block as deposit/withdrawal?
- [ ] Is there TWAP or time delay?
- [ ] Can flash loans manipulate the price feed?

---

## The Fix (Multiple Layers)

### Layer 1: Access Control
```solidity
address public authorized;

modifier onlyAuthorized() {
    require(msg.sender == authorized, "Unauthorized");
    _;
}

function updateTotalAum() external onlyAuthorized {
    // Only operator can update
}
```

### Layer 2: Time-Weighted Oracle (TWAP)
```solidity
uint256 public lastUpdateTime;
uint256 constant MIN_UPDATE_INTERVAL = 1 hours;

function updateTotalAum() external onlyAuthorized {
    require(
        block.timestamp >= lastUpdateTime + MIN_UPDATE_INTERVAL,
        "Too soon"
    );
    
    // Use TWAP, not spot price
    uint256 twapPrice = curvePool.get_dy(0, 1, 1e18); // Example
    lastTotalAum = calculateAUM(twapPrice);
    lastUpdateTime = block.timestamp;
}
```

### Layer 3: Chainlink Oracle (Preferred)
```solidity
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract SafeOracle {
    AggregatorV3Interface priceFeed;
    uint256 constant MAX_STALENESS = 3600; // 1 hour
    
    function getPrice() public view returns (uint256) {
        (
            uint80 roundId,
            int256 price,
            ,
            uint256 updatedAt,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        
        require(price > 0, "Invalid price");
        require(answeredInRound >= roundId, "Stale round");
        require(block.timestamp - updatedAt < MAX_STALENESS, "Stale price");
        
        return uint256(price);
    }
}
```

### Layer 4: Withdrawal Delay (Prevents Atomic Manipulation)
```solidity
mapping(address => uint256) public depositTime;
uint256 constant WITHDRAWAL_DELAY = 1 hours;

function deposit() external {
    depositTime[msg.sender] = block.timestamp;
    // ... deposit logic ...
}

function withdraw() external {
    require(
        block.timestamp >= depositTime[msg.sender] + WITHDRAWAL_DELAY,
        "Must wait before withdraw"
    );
    // ... withdrawal at current (un-manipulated) price ...
}
```

### Layer 5: Circuit Breakers
```solidity
uint256 public lastPrice;
uint256 constant MAX_PRICE_CHANGE = 1; // 1% per update

function updatePrice(uint256 newPrice) internal {
    if (lastPrice > 0) {
        uint256 delta = newPrice > lastPrice ? 
            newPrice - lastPrice : lastPrice - newPrice;
        
        require(
            delta * 100 / lastPrice <= MAX_PRICE_CHANGE,
            "Price movement too large"
        );
    }
    
    lastPrice = newPrice;
}
```

**Reference implementations:**
- Compound V3: Chainlink with staleness checks
- Aave V3: Multiple oracle sources, deviation limits
- Morpho: ChainlinkOracle with heartbeat validation

---

## Lessons for Protocol Developers

### 1. **"Out of Scope" = Unaudited Risk**
If auditors exclude an attack vector, that doesn't make it safe. It makes it YOUR responsibility.

Cantina excluded oracle manipulation. Three months later, oracle manipulation drained the protocol.

**Rule:** Audit exclusions = TODO list for YOU to verify or accept risk.

---

### 2. **Spot Price Oracles = Exploitable**
Any pricing based on current AMM pool state can be manipulated with flash loan capital.

**Safe patterns:**
- TWAP (time-weighted average)
- Chainlink oracles
- Multiple oracle sources with deviation checks
- Never raw `calc_withdraw_one_coin()` or `get_virtual_price()`

---

### 3. **Post-Audit Integrations = Unaudited Code**
Makina had 6 audits. The Curve pool integration deployed AFTER audits.

**Rule:** New integration = new audit. No exceptions.

---

### 4. **Permissionless Functions = Attack Surface**
If anyone can call `updatePrice()` or `updateAUM()`, attacker controls WHEN oracle reads state.

**Rule:** Oracle updates need access control OR time delays.

---

### 5. **Atomic Attacks Win**
Flash loan → manipulate → update → extract → repay. All in one transaction.

No time for monitoring. No time for intervention.

**Rule:** Prevention must be IN the code, not off-chain monitoring.

---

### 6. **MEV Front-Running Exists for Exploits**
Original attacker deployed contract, got completely front-run by MEV searcher who decompiled and replicated in 1 block.

**Lesson:** Unverified exploit contracts = public blueprints.

---

## Lessons for Auditors

### 1. **Don't Exclude Core Attack Vectors**
"Out of scope: oracle manipulation" on a protocol that uses AMM oracles = audit failure.

If a pattern is too risky to exclude, SAY SO in the report. Don't silently exclude.

---

### 2. **Test Post-Deployment Integrations**
Makina's Curve integration happened after audits. That integration WAS the vulnerability.

**Recommendation:** Include integration testing in scope, or require re-audit after deployment.

---

## Lessons for Attackers (Educational)

The Makina exploit demonstrated:

- **Reconnaissance:** Audit reports with exclusions = unaudited attack surface
- **Testing:** Flash loan manipulation is testable on fork before deploying
- **Execution:** Atomic transaction prevents intervention
- **Risk:** MEV bots can decompile and front-run your exploit

**If you're a white-hat:** This is the playbook. Find excluded attack vectors, prove them, earn bounties.

**If you're a protocol:** Assume attackers read your audit exclusions MORE carefully than you do.

---

## What Happens Next?

**Funds status:** 1,299 ETH distributed to MEV searcher's wallets. Original attacker got 0.

**Copycat risk:** Flash loan oracle manipulation is well-documented. Other protocols with similar patterns are at risk.

**Protocols to check:**
- Any vault using Curve `calc_withdraw_one_coin()` for pricing
- Permissionless price update functions
- Post-audit AMM integrations
- "Flexible" Weiroll command systems

---

## Conclusion

Makina lost $4.13M to a bug pattern that was EXCLUDED from audits.

Six top-tier audits. All missed it. Because it was marked "out of scope."

**For protocols:**
- "Out of scope" = your responsibility
- Post-audit integrations = new audits required
- Spot price oracles = flash loan attack surface
- Permissionless updates = attacker-controlled timing

**For auditors:**
- Don't exclude core attack vectors
- Test integrations, not just core contracts
- If you exclude something critical, say so loudly

**For attackers:**
- Audit exclusions = target list
- MEV bots read bytecode faster than you
- Atomic execution works, but you might get front-run

**Out of scope doesn't mean safe. It means unaudited.**

Fix it or accept the risk.

---

**References:**
- Attack tx: [Etherscan](https://etherscan.io/tx/0x569733b8016ef9418f0b6bde8c14224d9e759e79301499908ecbcd956a0651f5)
- Makina contract: `0x06147e073B854521c7B778280E7d7dBAfB2D4898`
- Cantina CTF scope: [Contest details]

---

*This content is educational. All exploit details are publicly documented on-chain and via security research platforms.*
