---
layout: post
title: "Solana Lending Security: Lessons from $200M in Exploits"
date: 2026-02-12 10:00:00 +0200
categories: [security, solana, lending]
tags: [solana, anchor, oracle-manipulation, account-validation, mango-markets, lending-protocol]
excerpt: "Deep technical analysis of five major Solana lending protocol exploits totaling $200M+. Learn the specific code patterns that led to Mango Markets ($116M), Cashio ($52.8M), and Crema ($8.8M) hacks — and how to prevent them."
author: "NexusWeb3 Security Research"
---

Between November 2022 and March 2023, Solana's DeFi ecosystem lost over $200 million to lending protocol exploits. These weren't sophisticated zero-days — they were preventable vulnerabilities in oracle integration, account validation, and mathematical precision.

This post breaks down five major incidents with transaction-level detail, vulnerable code patterns, and concrete detection methods for auditors.

---

## The $200M Portfolio

| Protocol | Date | Loss | Root Cause | Attack Vector |
|----------|------|------|------------|---------------|
| **Mango Markets** | Oct 2022 | **$116M** | Oracle manipulation | Artificial price inflation via thin markets |
| **Cashio** | Mar 2022 | **$52.8M** | Collateral validation bypass | Fake mint token accepted as collateral |
| **Solend** | Aug 2022 | **$0** (prevented) | Governance attack | Flash loan governance takeover attempt |
| **Crema Finance** | Jul 2022 | **$8.8M** | Tick array validation | Missing signer check on admin instruction |
| **Nirvana Finance** | Jul 2022 | **$3.5M** | Flash loan math error | Incorrect collateralization check |

**Total: $181.1M in realized losses** (Solend attack was prevented by emergency governance action)

---

## 1. Mango Markets: The $116M Oracle Manipulation

**Transaction:** `4RMrPmAGdAvxtNJUdF7MwiEKXfjoNciEbVdG2FMKaoSdNYeiyvmp3nKYmSTiojf3z5kKKS5pH3CqkLq2ZP4DdPB8`  
**Attacker:** `CQvKSNnYtPTZfQRQ5jkHq8q2swJyRsdQQcUfFqBSCtyj`  
**Date:** October 11, 2022

### The Attack

Mango Markets used **Pyth oracle prices** for collateral valuation. The attacker exploited thin liquidity in MNGO perpetual markets:

1. **Opened massive leveraged long positions** in MNGO-PERP on Mango (using $5M initial capital)
2. **Bought MNGO spot tokens** on low-liquidity DEXes (FTX, Ascendex) to pump the price
3. **Oracle updated** to reflect the manipulated price (~900% increase)
4. **Borrowed against inflated collateral** — withdrew $116M in SOL, USDC, BTC
5. **Let positions liquidate** after draining the protocol

### Vulnerable Pattern: Spot Price Oracles in Thin Markets

```rust
// VULNERABLE: Direct spot price usage without liquidity checks
pub fn get_price(ctx: Context<GetPrice>, market: Pubkey) -> Result<I80F48> {
    let oracle_account = &ctx.accounts.oracle;
    let price_data: &PriceAccount = load_pyth_price(oracle_account)?;
    
    // ❌ NO liquidity validation
    // ❌ NO TWAP comparison
    // ❌ NO circuit breaker for extreme moves
    
    Ok(I80F48::from_num(price_data.agg.price))
}

// Usage in collateral calculation
pub fn get_equity(account: &MangoAccount, markets: &[Market]) -> Result<I80F48> {
    let mut equity = I80F48::ZERO;
    for position in &account.positions {
        let price = get_price(position.market)?; // ❌ Manipulated price used here
        equity += position.base_position * price;
    }
    Ok(equity)
}
```

### The Fix: Multi-Layer Oracle Defense

```rust
// SECURE: Comprehensive oracle validation
pub fn get_safe_price(ctx: Context<GetPrice>, market: Pubkey) -> Result<I80F48> {
    let oracle = &ctx.accounts.oracle;
    let price_data: &PriceAccount = load_pyth_price(oracle)?;
    
    // 1. Staleness check
    let slot = Clock::get()?.slot;
    require!(
        slot - price_data.agg.pub_slot < MAX_ORACLE_STALENESS_SLOTS,
        ErrorCode::StaleOracle
    );
    
    // 2. Confidence interval check
    let confidence_pct = price_data.agg.conf
        .checked_div(price_data.agg.price.abs())
        .ok_or(ErrorCode::MathOverflow)?;
    require!(
        confidence_pct < MAX_CONFIDENCE_INTERVAL, // e.g., 2%
        ErrorCode::OracleConfidenceTooWide
    );
    
    // 3. Circuit breaker — compare to TWAP
    let twap = get_twap(market, TWAP_WINDOW)?;
    let deviation = (price_data.agg.price - twap).abs()
        .checked_div(twap)
        .ok_or(ErrorCode::MathOverflow)?;
    require!(
        deviation < MAX_DEVIATION_FROM_TWAP, // e.g., 10%
        ErrorCode::PriceDeviationTooHigh
    );
    
    // 4. Liquidity gate (if available from oracle)
    // For Pyth, check num_publishers and num_quoters
    require!(
        price_data.num_ >= MIN_PUBLISHERS,
        ErrorCode::InsufficientOraclePublishers
    );
    
    Ok(I80F48::from_num(price_data.agg.price))
}
```

### Detection Checklist

**For Auditors:**
- [ ] Does the protocol use spot prices for collateral valuation?
- [ ] Is there a TWAP or other manipulation-resistant price source?
- [ ] Are there circuit breakers for extreme price moves?
- [ ] Is oracle staleness checked on every read?
- [ ] Is the Pyth confidence interval validated?
- [ ] Can an attacker profitably manipulate the price given available liquidity?

**Red Flags:**
```rust
// ❌ Direct price usage without validation
let price = oracle.get_price()?;

// ❌ No staleness check
let price_data = /* oracle account */;
let price = price_data.price; // When was this updated?

// ❌ No comparison to alternative price sources
// If Pyth says $100 but Chainlink says $10, which is right?
```

---

## 2. Cashio: The $52.8M Fake Collateral Attack

**Transaction:** `2CuT6SHtaXrMdiSmHLBd3PvPNVzfY5JrhBqA8HMaDBSwtkYhNUJouUw6FzhdLMBLLr4wx2Bvev1b5fKdLDmRoCN`  
**Date:** March 23, 2022

### The Attack

Cashio Dollar (CASH) was an algorithmic stablecoin backed by USDC or USDT deposited into Saber LP pools. The protocol validated collateral by checking if a token account belonged to a specific Saber pool.

**The flaw:** It checked the **account type** but not the **mint address**.

The attacker:
1. **Created a fake Saber LP pool** with a worthless token
2. **Minted billions of fake LP tokens**
3. **Deposited fake LP tokens** into Cashio as "collateral"
4. **Minted $52.8M CASH** against worthless collateral
5. **Sold CASH for USDC/USDT** on DEXes before anyone noticed

### Vulnerable Pattern: Insufficient Collateral Validation

```rust
// VULNERABLE: Only checks account discriminator, not mint
#[derive(Accounts)]
pub struct DepositCollateral<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    
    #[account(mut)]
    pub user_collateral: Account<'info, TokenAccount>,
    
    // ❌ NO CONSTRAINT on token mint!
    // Any TokenAccount passes, regardless of mint address
    #[account(mut)]
    pub vault: Account<'info, TokenAccount>,
    
    pub token_program: Program<'info, Token>,
}

pub fn deposit_collateral(ctx: Context<DepositCollateral>, amount: u64) -> Result<()> {
    // Transfer tokens
    token::transfer(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.user_collateral.to_account_info(),
                to: ctx.accounts.vault.to_account_info(),
                authority: ctx.accounts.user.to_account_info(),
            },
        ),
        amount,
    )?;
    
    // ❌ Mint CASH against ANY token that was deposited!
    // No verification that user_collateral.mint == EXPECTED_COLLATERAL_MINT
    
    Ok(())
}
```

### The Fix: Strict Mint Validation

```rust
// SECURE: Explicit mint constraint
#[derive(Accounts)]
pub struct DepositCollateral<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    
    #[account(
        mut,
        constraint = user_collateral.mint == vault.mint @ ErrorCode::InvalidCollateralMint,
        constraint = user_collateral.owner == user.key() @ ErrorCode::InvalidTokenOwner
    )]
    pub user_collateral: Account<'info, TokenAccount>,
    
    #[account(
        mut,
        constraint = vault.mint == USDC_MINT || vault.mint == USDT_MINT @ ErrorCode::UnsupportedCollateral
    )]
    pub vault: Account<'info, TokenAccount>,
    
    pub token_program: Program<'info, Token>,
}

// Or for Saber LP tokens, validate the LP mint
#[account(
    constraint = is_valid_saber_lp_mint(user_collateral.mint) @ ErrorCode::InvalidSaberLP
)]
pub user_collateral: Account<'info, TokenAccount>,

// Validation function
pub fn is_valid_saber_lp_mint(mint: Pubkey) -> bool {
    // Derive expected Saber LP mint from pool seeds
    let (expected_lp_mint, _bump) = Pubkey::find_program_address(
        &[
            b"saber_lp",
            SABER_USDC_USDT_POOL.as_ref(),
        ],
        &saber_program::ID,
    );
    mint == expected_lp_mint
}
```

### Detection Checklist

**For Auditors:**
- [ ] Are all collateral token mints validated against a whitelist?
- [ ] Can a user deposit arbitrary tokens as collateral?
- [ ] Are LP tokens validated by deriving the expected mint from pool seeds?
- [ ] Is the token program ID checked (could be a fake SPL Token program)?
- [ ] Are all CPI calls to token programs validated?

**Red Flags:**
```rust
// ❌ Accepting any TokenAccount without mint check
pub user_token: Account<'info, TokenAccount>,

// ❌ Only checking account type, not specific mint
if account.owner == token_program::ID { /* accept */ }

// ❌ Hardcoded addresses without validation
const COLLATERAL_MINT: Pubkey = /* ... */; // Is this actually checked?
```

---

## 3. Crema Finance: The $8.8M Missing Signer Check

**Transaction:** `2VXW4a3AcfwxtsTFLhfdXF9zrjWJDKY3aULoLVME4Lk7Q8W8RcBzfGzVUg8FvA2JNNLmLcLmwBWCZ6W1Y7bVj7LQ`  
**Date:** July 3, 2022

### The Attack

Crema Finance is a concentrated liquidity AMM (similar to Uniswap V3). It had an admin function `update_tick_array` that allowed updating price tick data.

**The flaw:** The function accepted a `ClmmConfig` account parameter but **didn't verify the signer**.

The attacker:
1. **Called `update_tick_array`** with their own wallet as a fake "admin" account
2. **Overwrote tick array data** to manipulate pool reserves
3. **Swapped tokens** at the manipulated price
4. **Drained $8.8M** before the team could pause the protocol

### Vulnerable Pattern: Missing Signer Validation

```rust
// VULNERABLE: No signer check on admin account
#[derive(Accounts)]
pub struct UpdateTickArray<'info> {
    #[account(mut)]
    pub clmm_config: Account<'info, ClmmConfig>, // ❌ Should be constrained to admin
    
    #[account(mut)]
    pub tick_array: Account<'info, TickArrayState>,
}

pub fn update_tick_array(
    ctx: Context<UpdateTickArray>,
    tick_array_index: i32,
    initialized_tick_count: u16,
) -> Result<()> {
    let clmm_config = &ctx.accounts.clmm_config;
    
    // ❌ NO CHECK: is clmm_config.authority == signer?
    // Attacker can pass ANY ClmmConfig account (even one they control)
    
    let tick_array = &mut ctx.accounts.tick_array;
    tick_array.tick_array_index = tick_array_index;
    tick_array.initialized_tick_count = initialized_tick_count;
    
    Ok(())
}
```

### The Fix: Explicit Signer Constraint

```rust
// SECURE: Require admin signature
#[derive(Accounts)]
pub struct UpdateTickArray<'info> {
    // Admin must sign the transaction
    #[account(
        constraint = admin.key() == clmm_config.authority @ ErrorCode::Unauthorized
    )]
    pub admin: Signer<'info>,
    
    #[account(mut)]
    pub clmm_config: Account<'info, ClmmConfig>,
    
    #[account(
        mut,
        constraint = tick_array.clmm == clmm_config.key() @ ErrorCode::InvalidTickArray
    )]
    pub tick_array: Account<'info, TickArrayState>,
}

pub fn update_tick_array(
    ctx: Context<UpdateTickArray>,
    tick_array_index: i32,
    initialized_tick_count: u16,
) -> Result<()> {
    // Admin signature already enforced by Signer<'info> type + constraint
    
    let tick_array = &mut ctx.accounts.tick_array;
    tick_array.tick_array_index = tick_array_index;
    tick_array.initialized_tick_count = initialized_tick_count;
    
    Ok(())
}
```

### Detection Checklist

**For Auditors:**
- [ ] Do all admin/privileged functions require a `Signer<'info>` account?
- [ ] Is the signer validated against the expected authority?
- [ ] Can an attacker pass their own account as an admin/config parameter?
- [ ] Are PDA-derived accounts validated with `seeds` and `bump`?
- [ ] Are cross-program invocations properly validated?

**Red Flags:**
```rust
// ❌ Admin function without Signer requirement
pub fn admin_action(ctx: Context<AdminAction>) -> Result<()> {
    // Who called this? Anyone can!
}

// ❌ Authority check but no Signer type
pub config: Account<'info, Config>, // Anyone can pass any Config account

// ❌ Authority checked AFTER action
pub fn dangerous(ctx: Context<Action>) -> Result<()> {
    do_privileged_thing()?; // ❌ Happens before check
    require!(is_admin(), ErrorCode::Unauthorized);
    Ok(())
}
```

---

## 4. Nirvana Finance: The $3.5M Flash Loan Math Error

**Date:** July 28, 2022  
**Loss:** $3.5M

### The Attack

Nirvana Finance was an algorithmic stablecoin protocol. It had a flash loan function that allowed borrowing ANA tokens without collateral within a single transaction.

**The flaw:** The collateralization check used **token balances** instead of **accounting for locked tokens**.

The attacker:
1. **Flash loaned ANA tokens** from the protocol
2. **Staked the ANA tokens** in the same transaction
3. **Received staking derivatives** (which counted as collateral)
4. **Borrowed more ANA** against the staking derivatives
5. **Repaid the flash loan** with the newly borrowed ANA
6. **Kept the staking derivatives** and swapped them for $3.5M

### Vulnerable Pattern: Token Balance vs Accounting Balance

```rust
// VULNERABLE: Uses token account balance instead of logical accounting
pub fn flash_loan_check(ctx: Context<FlashLoan>) -> Result<()> {
    let vault = &ctx.accounts.vault;
    
    // ❌ Reads SPL token account balance
    let balance_after = vault.amount;
    let balance_before = ctx.accounts.balance_snapshot.amount;
    
    // ❌ This can be manipulated if the same tokens are moved to a different account!
    require!(
        balance_after >= balance_before,
        ErrorCode::FlashLoanNotRepaid
    );
    
    Ok(())
}
```

### The Fix: Logical Balance Tracking

```rust
// SECURE: Track logical debt, not token balances
#[account]
pub struct FlashLoanState {
    pub flash_loan_debt: u64,
    pub last_settlement_slot: u64,
}

pub fn flash_loan_start(ctx: Context<FlashLoanStart>, amount: u64) -> Result<()> {
    let state = &mut ctx.accounts.flash_loan_state;
    
    // Record the debt logically
    state.flash_loan_debt = state.flash_loan_debt
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;
    
    // Transfer tokens
    token::transfer(/* ... */)?;
    
    Ok(())
}

pub fn flash_loan_repay(ctx: Context<FlashLoanRepay>, amount: u64) -> Result<()> {
    let state = &mut ctx.accounts.flash_loan_state;
    
    // Transfer tokens back
    token::transfer(/* ... */)?;
    
    // Reduce debt
    state.flash_loan_debt = state.flash_loan_debt
        .checked_sub(amount)
        .ok_or(ErrorCode::InsufficientRepayment)?;
    
    Ok(())
}

pub fn flash_loan_settle(ctx: Context<FlashLoanSettle>) -> Result<()> {
    let state = &ctx.accounts.flash_loan_state;
    
    // Enforce: all flash loans must be repaid in the same slot
    let current_slot = Clock::get()?.slot;
    if state.flash_loan_debt > 0 {
        require!(
            current_slot == state.last_settlement_slot,
            ErrorCode::FlashLoanNotRepaidInSameSlot
        );
    }
    
    Ok(())
}
```

### Detection Checklist

**For Auditors:**
- [ ] Do flash loan repayment checks use logical accounting or token balances?
- [ ] Can tokens be moved to a different account to bypass repayment checks?
- [ ] Are flash loans enforced to be repaid in the same transaction/slot?
- [ ] Is there a reentrancy guard to prevent nested flash loans?
- [ ] Are fees properly accrued on flash loans?

---

## 5. Common Patterns Across All Exploits

### Pattern 1: Trusting External State

**Mango** trusted Pyth oracle prices without liquidity validation.  
**Cashio** trusted that a TokenAccount type meant it was the right mint.  
**Crema** trusted that a ClmmConfig account meant the caller was admin.

**Fix:** Validate everything. Never trust account types alone.

### Pattern 2: Missing Economic Invariants

**Nirvana** didn't enforce "flash loan debt must be zero before transaction ends."  
**Mango** didn't enforce "collateral value cannot change >X% in one transaction."

**Fix:** Define invariants in comments and enforce them in code.

```rust
// INVARIANT: Total debt across all users <= total_deposits * max_borrow_ratio
pub fn borrow(ctx: Context<Borrow>, amount: u64) -> Result<()> {
    // ... borrow logic ...
    
    // Enforce invariant
    let state = &ctx.accounts.lending_pool_state;
    let utilization = state.total_debt
        .checked_div(state.total_deposits)
        .ok_or(ErrorCode::MathOverflow)?;
    require!(
        utilization <= state.max_borrow_ratio,
        ErrorCode::BorrowCapExceeded
    );
    
    Ok(())
}
```

### Pattern 3: Precision Loss in Interest Calculations

Solana uses **64-bit integers**. No native decimals. Every lending protocol must implement fixed-point math.

**Common bug:**
```rust
// ❌ WRONG: Precision loss in division
let interest_rate_per_slot = annual_rate / SLOTS_PER_YEAR; // Rounds to zero for small rates!

// ✅ CORRECT: Scale up before division
let interest_rate_per_slot = (annual_rate * PRECISION) / SLOTS_PER_YEAR;
```

Use `I80F48` (80-bit signed fixed-point) or `U192` for intermediate calculations.

---

## Detection Toolkit for Auditors

### 1. Oracle Validation Checklist

```rust
// Required checks for every oracle price read:
// [ ] Staleness check (pub_slot within N slots of current)
// [ ] Confidence interval check (conf / price < threshold)
// [ ] TWAP comparison (spot price within X% of TWAP)
// [ ] Liquidity check (sufficient publishers/quoters)
// [ ] Circuit breaker (price change within max deviation)
```

### 2. Account Validation Checklist

```rust
// For every Account<'info, T> parameter:
// [ ] Is the mint address validated (for TokenAccount)?
// [ ] Is the owner/authority validated?
// [ ] Are seeds/bump validated (for PDA)?
// [ ] Is the account type sufficient, or is a discriminator needed?
// [ ] Can an attacker pass their own account instead?
```

### 3. Signer Validation Checklist

```rust
// For every privileged instruction:
// [ ] Is there a Signer<'info> account?
// [ ] Is the signer constraint checked against the expected authority?
// [ ] Are all code paths gated by the signer check?
// [ ] Can the check be bypassed via CPI?
```

### 4. Math Safety Checklist

```rust
// For every arithmetic operation in finance logic:
// [ ] Is checked_add/checked_sub/checked_mul/checked_div used?
// [ ] Are divisions scaled to prevent precision loss?
// [ ] Is the order of operations correct (mul before div)?
// [ ] Are intermediate values large enough to prevent overflow?
// [ ] Are negative numbers handled correctly?
```

---

## Conclusion: The $200M Lesson

These five exploits share a common theme: **insufficient validation of external state and arithmetic precision**.

Solana's account model is powerful but requires explicit validation of:
- **Oracle data** (staleness, confidence, manipulation resistance)
- **Account ownership** (mint, authority, PDA seeds)
- **Signer requirements** (who can call this instruction?)
- **Math precision** (fixed-point arithmetic, checked operations)

**For protocol developers:**
- Read Mango's post-mortem and implement their oracle safety measures
- Use Anchor constraints aggressively (especially `seeds`, `bump`, `constraint`)
- Write invariant tests (not just happy-path tests)
- Hire professional auditors before mainnet (OtterSec, Neodyme, Sec3)

**For auditors:**
- Spend 50% of your time on oracle integration and account validation
- Build a checklist and apply it to every instruction
- Look for "trust" — any time the code assumes an account is valid without checking
- Test with mainnet forks and real adversarial transactions

**For users:**
- Use protocols that have been audited by multiple firms
- Check if the protocol has oracle circuit breakers
- Monitor on-chain activity for unusual price movements
- Never ape into unaudited forks of popular protocols

---

## References

- [Mango Markets Post-Mortem](https://github.com/blockworks-foundation/mango-v3/blob/main/docs/postmortem.md)
- [OtterSec: Cashio Exploit Analysis](https://osec.io/blog/2022-03-24-cashio-exploit)
- [Crema Finance Incident Report](https://medium.com/@Crema_Finance/incident-report-july-3-2022-d58ab5a2a66e)
- [Solana Security Best Practices](https://github.com/coral-xyz/sealevel-attacks)
- [Neodyme: Solana Smart Contract Audits](https://github.com/neodyme-labs/solana-security-txt)

---

*Want more deep-dives? Follow our research at [github.com/nexusweb3dev](https://github.com/nexusweb3dev)*
